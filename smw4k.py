# smw_multiworld_remix.py
# NES-flavored Super Mario World-inspired, multi-world remix.
# Single file. No assets. 60 FPS. PS1/NES vibes. Autogenerated levels.
# Requires: pip install pygame

import pygame as pg
import sys, random, math, threading

# ---- tiny beeps (winsound if available, safe fallback) ----
def _noop(*a, **k): pass
try:
    import winsound
    def tone(f=440, ms=60):
        try: winsound.Beep(int(f), int(ms))
        except Exception: pass
    def seq(s):
        def run():
            for f,d in s: tone(f,d)
        threading.Thread(target=run, daemon=True).start()
except Exception:
    tone = _noop
    def seq(s): pass

def sfx(tag):
    if tag == 'jump': tone(660, 60)
    elif tag == 'coin': tone(880, 60)
    elif tag == 'stomp': tone(220, 60)
    elif tag == 'power': seq([(500,80),(700,80)])
    elif tag == 'hit': tone(200, 120)
    elif tag == 'goal': seq([(660,120),(880,120),(990,160)])
    elif tag == 'over': seq([(300,200),(220,200),(160,240)])
    elif tag == 'pipe': seq([(260,70),(200,90)])

# ---- config ----
FPS = 60
RENDER_W, RENDER_H = 256, 240  # NES-ish
SCALE = 3
WIN_W, WIN_H = RENDER_W*SCALE, RENDER_H*SCALE

TILE = 16
MAP_H_TILES = RENDER_H // TILE  # 15
GRAVITY = 1200.0
MOVE_ACC = 1800.0
MOVE_FRICTION = 1800.0
WALK_SPEED = 120.0
RUN_SPEED = 200.0
JUMP_VELOCITY = 360.0
JUMP_HOLD_TIME = 0.18
TERMINAL_V = 640.0

# palettes per world
PALETTES = {
    'grass': ((92, 180, 92), (60, 60, 60), (140, 200, 255)),
    'desert': ((216, 180, 90), (90, 70, 50), (180, 150, 80)),
    'water': ((100, 180, 216), (40, 60, 90), (160, 210, 240)),
    'mountain': ((140, 160, 160), (70, 70, 80), (150, 200, 230)),
    'forest': ((100, 160, 100), (50, 70, 50), (140, 190, 200)),
    'ice': ((200, 230, 240), (100, 120, 160), (220, 240, 255)),
    'sky': ((220, 220, 240), (100, 100, 120), (220, 240, 255)),
    'castle': ((160, 120, 120), (70, 50, 50), (120, 110, 120)),
    'star': ((200, 180, 255), (80, 60, 100), (240, 230, 255)),
}
WORLD_ORDER = ['grass','desert','water','mountain','forest','ice','sky','castle','star']

def clamp(v, a, b): return max(a, min(b, v))
def sign(v): return -1 if v < 0 else (1 if v > 0 else 0)
def ps1_jitter(t, phase=0.0, amp=0.6): return math.sin(t*7.1 + phase) * amp

# ---- tile flags ----
SOLID = set('#B=HPTKW')  # ground/brick/blocks/pipes/walls/k=castle
__ALL_TILES__ = " #.=C?B^PpG|HWTKLRk~"
# ' ' air, '#' ground, '.' bg, '=' platform (one-way), 'C' coin, '?' question,
# 'B' brick, '^' spike, 'P' pipe-top, 'p' pipe-body, 'G' goal, '|' pole,
# 'H' hard block, 'W' water (swim), 'T' spring, 'K' crate, 'L' lava, 'R' rope,
# 'k' castle brick, '~' waterfall deco

# ---- level generation (procedural patterns per world) ----
def gen_level(world, stage, seed=None):
    rnd = random.Random((hash(world) ^ (stage*7777)) if seed is None else seed)
    width = rnd.randint(140, 200)  # tiles
    height = MAP_H_TILES  # 15
    rows = [[' ']*width for _ in range(height)]

    # base sky/bg
    for y in range(height):
        for x in range(width):
            rows[y][x] = ' '

    # theme params
    theme = world
    ground_y = 12
    holes = max(2, 2 + stage + WORLD_ORDER.index(world)//1)
    pipes = 4 if world in ('grass','desert','forest') else 2
    spikes = 3 if world in ('mountain','castle') else 1
    waterbands = 2 if world == 'water' else 0
    ice = (world == 'ice')
    springs = 1 if world in ('sky','mountain') else 0
    lava = (world == 'castle')

    # ground
    x = 0
    while x < width:
        seg_len = rnd.randint(6, 16)
        # occasional slopes via stepping
        base = ground_y + rnd.choice([0,0,0,-1,1])
        base = clamp(base, 9, 13)
        for i in range(seg_len):
            gy = base
            # fill ground downwards
            for y in range(gy, height):
                rows[y][x] = '#' if not lava else ('L' if y >= gy+1 else '#')
            # platform decor
            if rnd.random() < 0.1 and gy > 4:
                rows[gy-3][x] = '='
            x += 1
            if x >= width: break

    # carve holes
    for _ in range(holes):
        hx = rnd.randint(12, width-18)
        hw = rnd.randint(2, 4 + stage//2)
        for x in range(hx, min(width-1, hx+hw)):
            for y in range(ground_y, height):
                rows[y][x] = ' ' if not lava else 'L'
        # add platform bridge sometimes
        if rnd.random() < 0.5:
            for x in range(hx, min(width-1, hx+hw)):
                rows[ground_y-2][x] = '='

    # pipes
    for _ in range(pipes):
        px = rnd.randint(10, width-20)
        ph = rnd.randint(2, 4)
        for h in range(ph):
            rows[ground_y - h][px] = 'p'
            rows[ground_y - h][px+1] = 'p'
        rows[ground_y - ph][px] = 'P'
        rows[ground_y - ph][px+1] = 'P'

    # spikes
    for _ in range(spikes):
        sx = rnd.randint(10, width-20)
        for x in range(sx, sx+rnd.randint(2,4)):
            rows[ground_y-1][x] = '^'

    # water (water world)
    for _ in range(waterbands):
        wx = rnd.randint(12, width-28)
        ww = rnd.randint(6, 12)
        for x in range(wx, wx+ww):
            for y in range(ground_y-1, height):
                rows[y][x] = 'W'
        # safe platforms
        for x in range(wx, wx+ww, 2):
            rows[ground_y-3][x] = '='

    # springs
    if springs:
        for _ in range(2):
            sx = rnd.randint(14, width-20)
            rows[ground_y-1][sx] = 'T'

    # coins and blocks
    for _ in range(40):
        cx = rnd.randint(6, width-8)
        cy = rnd.randint(4, ground_y-3)
        if rows[cy][cx] == ' ' and rows[cy+1][cx] == ' ':
            rows[cy][cx] = 'C'
    for _ in range(18):
        bx = rnd.randint(8, width-10)
        by = rnd.randint(5, ground_y-2)
        if rows[by][bx] == ' ':
            rows[by][bx] = '?' if rnd.random()<0.6 else 'B'

    # castle flavor
    if world == 'castle':
        for x in range(4, width-4):
            for y in range(ground_y-3, height):
                if rows[y][x] == '#':
                    rows[y][x] = 'k'
        # more spikes/lava
        for x in range(8, width-8, 12):
            rows[ground_y-1][x] = '^'
        for x in range(20, width-20):
            if rows[ground_y][x] == '#':
                rows[ground_y][x] = 'L'

    # star world sparkle
    if world == 'star':
        for _ in range(200):
            x = rnd.randint(0, width-1)
            y = rnd.randint(2, ground_y-3)
            if rows[y][x] == ' ':
                rows[y][x] = '.'

    # start/goal
    rows[ground_y-1][4] = '.'
    goal_x = width - 6
    rows[ground_y-8][goal_x] = '|'
    for y in range(ground_y-7, ground_y+1):
        rows[y][goal_x] = '|'
    rows[ground_y-1][goal_x+1] = 'G'

    # enemies
    enemies = []
    enemy_kinds = enemy_set_for_world(world)
    for _ in range(20):
        ex = rnd.randint(10, width-12)
        ey = ground_y-1
        # place only if solid below and space above
        if rows[ey][ex] == ' ' and rows[ey+1][ex] in ('#','k','='):
            kind = rnd.choice(enemy_kinds)
            enemies.append({'x': ex*TILE+8, 'y': ey*TILE, 'kind': kind, 'dir': rnd.choice([-1,1])})

    # to strings
    return ["".join(r) for r in rows], enemies, ground_y, width

def enemy_set_for_world(world):
    if world in ('grass','forest'): return ['goomba','koopa']
    if world == 'desert': return ['goomba','spiker']
    if world == 'water': return ['cheep']
    if world == 'mountain': return ['goomba','plant']
    if world == 'ice': return ['goomba','slipper']
    if world == 'sky': return ['para','koopa']
    if world == 'castle': return ['dry','fire']
    if world == 'star': return ['para','spiker','cheep']
    return ['goomba']

# ---- level runtime ----
class Level:
    def __init__(self, world, stage):
        self.world = world
        self.stage = stage
        self.rows, self.enemies, self.ground_y, self.w = gen_level(world, stage)
        self.h = len(self.rows)
        self.mod = {}  # (tx,ty)->char for dynamic changes (hit blocks, coins)
        self.camera_x = 0.0
        self.completed = False
        self.dead = False
        self.time = 400  # seconds-ish counter
        self.time_acc = 0.0

    def in_bounds(self, tx, ty):
        return 0 <= ty < self.h and 0 <= tx < self.w

    def get(self, tx, ty):
        if not self.in_bounds(tx, ty): return ' '
        return self.mod.get((tx,ty), self.rows[ty][tx])

    def set_tile(self, tx, ty, ch):
        if self.in_bounds(tx,ty):
            self.mod[(tx,ty)] = ch

    def solids_rects(self, rect):
        out = []
        tx0 = max(0, int(rect.left//TILE) - 1)
        tx1 = min(self.w-1, int(rect.right//TILE) + 1)
        ty0 = max(0, int(rect.top//TILE) - 1)
        ty1 = min(self.h-1, int(rect.bottom//TILE) + 1)
        for ty in range(ty0, ty1+1):
            for tx in range(tx0, tx1+1):
                ch = self.get(tx,ty)
                if ch in SOLID or ch in ('='):
                    # '=' treated as solid from top only later
                    out.append((pg.Rect(tx*TILE, ty*TILE, TILE, TILE), ch))
        return out

    def coins_rects(self, rect):
        res = []
        tx0 = max(0, int(rect.left//TILE)-1)
        tx1 = min(self.w-1, int(rect.right//TILE)+1)
        ty0 = max(0, int(rect.top//TILE)-1)
        ty1 = min(self.h-1, int(rect.bottom//TILE)+1)
        for ty in range(ty0, ty1+1):
            for tx in range(tx0, tx1+1):
                if self.get(tx,ty) == 'C':
                    r = pg.Rect(tx*TILE, ty*TILE, TILE, TILE)
                    if rect.colliderect(r):
                        res.append((tx,ty))
        return res

# ---- player ----
class Player:
    def __init__(self, x, y):
        self.x = x; self.y = y
        self.vx = 0; self.vy = 0
        self.w = 12; self.h = 14
        self.on_ground = False
        self.jump_hold = 0.0
        self.facing = 1
        self.alive = True
        self.coins = 0

    @property
    def rect(self):
        return pg.Rect(int(self.x)-self.w//2, int(self.y)-self.h, self.w, self.h)

# ---- enemies ----
class Enemy:
    def __init__(self, x, y, kind, dir=1):
        self.x = x; self.y = y
        self.vx = 40*dir; self.vy = 0
        self.kind = kind
        self.alive = True
        self.w = 12; self.h = 12
        self.timer = 0.0

    @property
    def rect(self):
        return pg.Rect(int(self.x)-self.w//2, int(self.y)-self.h, self.w, self.h)

# ---- physics & interactions ----
def update_player(pl, lvl, dt, keys, run_pressed, jump_pressed, jump_held, theme):
    if not pl.alive: return
    max_spd = RUN_SPEED if run_pressed else WALK_SPEED

    # horizontal accel/friction
    ax = 0.0
    if keys[pg.K_LEFT]: ax -= MOVE_ACC
    if keys[pg.K_RIGHT]: ax += MOVE_ACC
    if ax == 0:
        if pl.on_ground:
            pl.vx = approach(pl.vx, 0, MOVE_FRICTION*dt)
    else:
        pl.vx = approach(pl.vx, max_spd*sign(ax), MOVE_ACC*dt)
        pl.facing = sign(ax)

    # ice lower friction
    if theme == 'ice':
        pl.vx = clamp(pl.vx, -max_spd*1.2, max_spd*1.2)
    else:
        pl.vx = clamp(pl.vx, -max_spd, max_spd)

    # gravity
    water = tile_under(lvl, pl.rect, 'W')
    grav = GRAVITY * (0.35 if water else 1.0)
    pl.vy = min(TERMINAL_V*(0.35 if water else 1.0), pl.vy + grav*dt)

    # jump
    if jump_pressed and pl.on_ground:
        pl.vy = -JUMP_VELOCITY * (0.7 if water else 1.0)
        pl.jump_hold = JUMP_HOLD_TIME
        pl.on_ground = False
        sfx('jump')
    if jump_held and pl.jump_hold > 0:
        pl.jump_hold -= dt
        pl.vy -= 900.0*dt  # variable height
    if not jump_held:
        pl.jump_hold = 0

    # springs
    if collide_with_tile(lvl, pl.rect.move(0,1), 'T'):
        pl.vy = -JUMP_VELOCITY*1.4
        sfx('power')

    # movement + collisions
    # horizontal
    nx = pl.x + pl.vx*dt
    rect_next = pg.Rect(int(nx)-pl.w//2, pl.rect.top, pl.w, pl.h)
    solids = lvl.solids_rects(rect_next)
    blocked = False
    for r, ch in solids:
        if rect_next.colliderect(r):
            # allow passing through '=' from below
            if ch == '=':
                continue
            blocked = True
            if pl.vx > 0:
                rect_next.right = r.left
            elif pl.vx < 0:
                rect_next.left = r.right
            pl.vx = 0
    pl.x = rect_next.centerx

    # vertical
    ny = pl.y + pl.vy*dt
    rect_next = pg.Rect(pl.rect.left, int(ny)-pl.h, pl.w, pl.h)
    solids = lvl.solids_rects(rect_next)
    new_on_ground = False
    for r, ch in solids:
        if rect_next.colliderect(r):
            top_only = (ch == '=')
            if pl.vy > 0:
                if top_only and rect_next.bottom - r.top < 10:
                    rect_next.bottom = r.top
                    pl.vy = 0
                    new_on_ground = True
                elif not top_only:
                    rect_next.bottom = r.top
                    pl.vy = 0
                    new_on_ground = True
            elif pl.vy < 0 and not top_only:
                rect_next.top = r.bottom
                pl.vy = 0
                # bump blocks
                hit_block_pos = (r.left//TILE, r.top//TILE)
                bump_block(lvl, hit_block_pos)
    pl.y = rect_next.bottom
    pl.on_ground = new_on_ground

    # spikes/lava
    if collide_with_tile(lvl, pl.rect, '^') or collide_with_tile(lvl, pl.rect, 'L'):
        player_die(pl, lvl)

    # pipe down
    if keys[pg.K_DOWN] and pl.on_ground:
        if collide_with_tile(lvl, pl.rect, 'P'):
            sfx('pipe')
            lvl.completed = True  # treat as warp->goal

    # coins pickup
    for tx,ty in lvl.coins_rects(pl.rect):
        lvl.set_tile(tx,ty,'.')
        pl.coins += 1
        sfx('coin')

    # time
    lvl.time_acc += dt
    if lvl.time_acc >= 1.0:
        lvl.time_acc -= 1.0
        lvl.time = max(0, lvl.time-1)
        if lvl.time == 0:
            player_die(pl, lvl)

    # goal
    if collide_with_tile(lvl, pl.rect, 'G') or collide_with_tile(lvl, pl.rect, '|'):
        lvl.completed = True
        sfx('goal')

def approach(v, target, delta):
    if v < target: return min(v+delta, target)
    if v > target: return max(v-delta, target)
    return v

def collide_with_tile(lvl, rect, tile_char):
    tx0 = max(0, rect.left//TILE - 1)
    tx1 = min(lvl.w-1, rect.right//TILE + 1)
    ty0 = max(0, rect.top//TILE - 1)
    ty1 = min(lvl.h-1, rect.bottom//TILE + 1)
    for ty in range(ty0, ty1+1):
        for tx in range(tx0, tx1+1):
            if lvl.get(tx,ty) == tile_char:
                if rect.colliderect(pg.Rect(tx*TILE, ty*TILE, TILE, TILE)):
                    return True
    return False

def tile_under(lvl, rect, tile_char):
    probe = rect.move(0, 2)
    return collide_with_tile(lvl, probe, tile_char)

def bump_block(lvl, pos):
    tx, ty = pos
    ch = lvl.get(tx,ty)
    below = lvl.get(tx,ty+1)
    # '?' -> coin and become '.'
    if ch == '?':
        lvl.set_tile(tx,ty,'.')
        sfx('coin')
    elif ch == 'B':  # brick shatter to '.'
        lvl.set_tile(tx,ty,'.')
        sfx('hit')
    elif ch == 'H':  # hard block stays
        sfx('hit')

def player_die(pl, lvl):
    if not pl.alive: return
    pl.alive = False
    lvl.dead = True
    sfx('over')

def update_enemies(lvl, enemies, dt, pl):
    for e in enemies:
        if not e['kind'] or e.get('dead'): continue
        kind = e['kind']
        # gravity
        e['vy'] = e.get('vy', 0) + GRAVITY*dt
        e['vy'] = min(e['vy'], TERMINAL_V)
        # simple AI
        spd = 40 if kind in ('goomba','dry') else 50
        if kind in ('cheep',):
            # swim pattern
            e['vy'] = math.sin(pg.time.get_ticks()*0.004 + (e['x']*0.01))*20
            spd = 30
        e['vx'] = spd * e['dir']

        # move & collide with tiles
        rect = pg.Rect(int(e['x'])-6, int(e['y'])-12, 12, 12)
        # horizontal
        nx = e['x'] + e['vx']*dt
        rect_next = rect.copy(); rect_next.centerx = int(nx)
        blocked = False
        for r,ch in lvl.solids_rects(rect_next):
            if rect_next.colliderect(r) and ch != '=':
                blocked = True
                break
        if blocked:
            e['dir'] *= -1
        else:
            e['x'] = nx

        # vertical
        ny = e['y'] + e['vy']*dt
        rect_next = pg.Rect(int(e['x'])-6, int(ny)-12, 12, 12)
        grounded = False
        for r,ch in lvl.solids_rects(rect_next):
            if rect_next.colliderect(r):
                if e['vy'] > 0:
                    rect_next.bottom = r.top
                    e['vy'] = 0
                    grounded = True
                elif e['vy'] < 0 and ch != '=':
                    rect_next.top = r.bottom
                    e['vy'] = 0
        e['y'] = rect_next.bottom

        # edge turn
        if grounded:
            tx = (int(e['x'])//TILE) + (1 if e['dir']>0 else -1)
            ty = int(e['y'])//TILE
            below = lvl.get(tx, ty+1)
            if below == ' ' or below == 'W' or below == 'L':
                e['dir'] *= -1

        # player interactions
        if pl.alive:
            er = pg.Rect(int(e['x'])-6, int(e['y'])-12, 12, 12)
            pr = pl.rect
            if pr.colliderect(er):
                if pl.vy > 30 and pr.bottom <= er.top + 8:
                    # stomp
                    e['dead'] = True
                    sfx('stomp')
                    pl.vy = -JUMP_VELOCITY*0.6
                else:
                    player_die(pl, lvl)

# ---- overworld ----
class Overworld:
    def __init__(self):
        self.nodes = []
        for i, w in enumerate(WORLD_ORDER):
            self.nodes.append({'world': w, 'unlocked': (i==0), 'cleared': False})
        self.index = 0

    def unlocked_indices(self):
        return [i for i,n in enumerate(self.nodes) if n['unlocked']]

    def current_world(self):
        return self.nodes[self.index]['world']

    def mark_world_cleared(self, w):
        for i,n in enumerate(self.nodes):
            if n['world']==w:
                n['cleared'] = True
                if i+1 < len(self.nodes):
                    self.nodes[i+1]['unlocked'] = True

# ---- rendering helpers ----
def draw_scanlines(surface):
    sl = pg.Surface((RENDER_W, 1), pg.SRCALPHA)
    sl.fill((0,0,0,28))
    for y in range(0, RENDER_H, 2):
        surface.blit(sl, (0, y))

def draw_text(surf, text, x, y, color=(255,255,255), scale=1):
    font = pg.font.SysFont(None, 16)
    img = font.render(text, True, color)
    if scale != 1:
        img = pg.transform.scale(img, (img.get_width()*scale, img.get_height()*scale))
    surf.blit(img, (x,y))

def draw_level(surface, lvl, pl, enemies, t, pal):
    bg, fg, sky = palette_for_world(pal)
    surface.fill(sky)
    # parallax decor
    for i in range(24):
        px = int((i*48 - lvl.camera_x*0.3) % (RENDER_W+96)) - 48
        pg.draw.circle(surface, (bg[0]//2, bg[1]//2, bg[2]//2), (px, 40+int(5*math.sin(i+t))), 20, 1)

    camx = int(lvl.camera_x)

    # tiles
    ty0 = 0; ty1 = lvl.h
    tx0 = max(0, camx//TILE - 2)
    tx1 = min(lvl.w-1, (camx+RENDER_W)//TILE + 2)
    for ty in range(ty0, ty1):
        for tx in range(tx0, tx1+1):
            ch = lvl.get(tx,ty)
            if ch == ' ': continue
            rx = tx*TILE - camx; ry = ty*TILE
            col = (0,0,0)
            if ch in ('#','k'): col = bg
            elif ch == '=': col = (180, 180, 180)
            elif ch == 'C': col = (255, 220, 80)
            elif ch == '?': col = (200, 160, 80)
            elif ch == 'B': col = (150, 120, 90)
            elif ch == 'P' or ch == 'p': col = (100, 200, 100)
            elif ch == '^': col = (200, 60, 60)
            elif ch == 'W': col = (100, 160, 220)
            elif ch == 'L': col = (240, 80, 40)
            elif ch == 'T': col = (120, 240, 120)
            elif ch == 'G' or ch == '|': col = (240, 240, 240)
            elif ch == '.': col = (220, 220, 240)
            else: col = fg
            pg.draw.rect(surface, col, (rx, ry, TILE, TILE))
            # small outline for solids
            if ch in SOLID or ch in ('='):
                pg.draw.rect(surface, (0,0,0), (rx, ry, TILE, TILE), 1)

    # enemies
    for e in enemies:
        if e.get('dead'): continue
        rx = int(e['x']) - camx
        ry = int(e['y'])
        col = (200, 160, 120)
        if e['kind'] in ('koopa','dry'): col = (120, 200, 160)
        if e['kind'] in ('spiker','fire'): col = (220, 80, 80)
        if e['kind'] in ('cheep',): col = (120, 200, 240)
        if e['kind'] in ('para',): col = (240, 240, 240)
        jitter = int(ps1_jitter(t, 0.7, 0.6))
        pg.draw.rect(surface, col, (rx-6+jitter, ry-12, 12, 12))
        pg.draw.rect(surface, (0,0,0), (rx-6+jitter, ry-12, 12, 12), 1)

    # player
    jitter = int(ps1_jitter(t, 0.3, 0.6))
    pr = pl.rect
    pg.draw.rect(surface, (220, 60, 60), (pr.left - camx + jitter, pr.top, pr.w, pr.h))
    pg.draw.rect(surface, (0,0,0), (pr.left - camx + jitter, pr.top, pr.w, pr.h), 1)

def palette_for_world(world):
    if world not in PALETTES: world = 'grass'
    base, dark, sky = PALETTES[world]
    return base, dark, sky

def draw_hud(surface, world, stage, coins, time_left):
    draw_text(surface, f"WORLD {WORLD_ORDER.index(world)+1}-{stage+1}", 8, 8, (255,255,255), 1)
    draw_text(surface, f"COINS {coins:03d}", 8, 24, (255,255,100), 1)
    draw_text(surface, f"TIME {time_left:03d}", RENDER_W-120, 8, (240,240,240), 1)

def draw_overworld(surface, ow, sel_idx, t):
    surface.fill((30, 40, 70))
    draw_text(surface, "SUPER MARIO WORLD — NES remix", 16, 10, (240,240,240), 1)
    draw_text(surface, "Select a world and press Enter", 32, 30, (220,220,220), 1)
    # nodes in grid
    cols = 3
    for i, node in enumerate(ow.nodes):
        row = i // cols
        col = i % cols
        cx = 40 + col*80
        cy = 70 + row*50
        unlocked = node['unlocked']
        cleared = node['cleared']
        r = 16
        colr = (120, 120, 120)
        if unlocked: colr = (100, 220, 120)
        if cleared: colr = (220, 220, 80)
        if i == sel_idx:
            r += 3
        pg.draw.circle(surface, colr, (cx, cy), r)
        pg.draw.circle(surface, (0,0,0), (cx, cy), r, 2)
        name = node['world'].upper()
        draw_text(surface, name, cx-30, cy+20, (220,220,220), 1)

# ---- main loop ----
def main():
    pg.init()
    pg.display.set_caption("SMW NES Remix — multi-world | vibes=ON | 60 FPS")
    window = pg.display.set_mode((WIN_W, WIN_H))
    clock = pg.time.Clock()
    canvas = pg.Surface((RENDER_W, RENDER_H))

    state = 'overworld'  # or 'level', 'clear', 'dead'
    ow = Overworld()
    sel_idx = 0
    world = ow.current_world()
    stage = 0
    level = None
    player = None
    enemies = []
    t = 0.0

    def start_level(selected_world, st):
        nonlocal level, player, enemies, state
        level = Level(selected_world, st)
        spawn_y = (level.ground_y-1)*TILE
        player = Player(6*TILE, spawn_y)
        enemies = [dict(e) for e in level.enemies]
        state = 'level'

    start_level(world, 0)  # preload first

    running = True
    while running:
        dt = clock.tick(FPS)/1000.0
        t += dt
        for e in pg.event.get():
            if e.type == pg.QUIT:
                running = False
            elif e.type == pg.KEYDOWN:
                if e.key == pg.K_ESCAPE:
                    running = False
                if state == 'overworld':
                    if e.key == pg.K_RIGHT:
                        sel_idx = min(len(ow.nodes)-1, sel_idx+1)
                        if not ow.nodes[sel_idx]['unlocked']:
                            sel_idx = max(i for i in ow.unlocked_indices())
                    elif e.key == pg.K_LEFT:
                        sel_idx = max(0, sel_idx-1)
                        if not ow.nodes[sel_idx]['unlocked']:
                            sel_idx = min(ow.unlocked_indices())
                    elif e.key in (pg.K_RETURN, pg.K_KP_ENTER):
                        if ow.nodes[sel_idx]['unlocked']:
                            world = ow.nodes[sel_idx]['world']
                            stage = 0
                            start_level(world, stage)
                elif state == 'level':
                    if e.key == pg.K_r:
                        start_level(world, stage)

        # update
        if state == 'level':
            keys = pg.key.get_pressed()
            run_pressed = keys[pg.K_x] or keys[pg.K_LSHIFT]
            jump_pressed = (keys[pg.K_z] or keys[pg.K_k])
            # edge detect jump press
            # naive: use event-based or remember previous; keep simple:
            jump_held = jump_pressed

            update_player(player, level, dt, keys, run_pressed, jump_pressed, jump_held, world)
            update_enemies(level, enemies, dt, player)

            # camera follow
            target_cam = int(player.x - RENDER_W*0.4)
            level.camera_x = approach(level.camera_x, clamp(target_cam, 0, level.w*TILE-RENDER_W), dt*240)

            # deaths and clears
            if level.dead:
                state = 'dead'
                dead_timer = 1.2
            if level.completed:
                state = 'clear'
                clear_timer = 1.2

        elif state == 'clear':
            clear_timer -= dt
            if clear_timer <= 0:
                # next stage or world clear
                stage += 1
                if stage >= 4:
                    ow.mark_world_cleared(world)
                    state = 'overworld'
                else:
                    start_level(world, stage)

        elif state == 'dead':
            dead_timer -= dt
            if dead_timer <= 0:
                # retry same stage
                start_level(world, stage)

        # render
        canvas.fill((0,0,0))
        if state in ('level','clear','dead'):
            draw_level(canvas, level, player, enemies, t, world)
            draw_hud(canvas, world, stage, player.coins if player else 0, level.time if level else 0)
        elif state == 'overworld':
            draw_overworld(canvas, ow, sel_idx, t)

        draw_scanlines(canvas)
        # subtle jitter upscale
        jx = int(ps1_jitter(t, 0.3, 1.0))
        jy = int(ps1_jitter(t, 1.1, 1.0))
        surf = pg.transform.scale(canvas, (WIN_W, WIN_H))
        window.fill((0,0,0))
        window.blit(surf, (jx, jy))
        pg.display.flip()

    pg.quit()
    sys.exit()

if __name__ == '__main__':
    main()
